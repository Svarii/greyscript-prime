// Return true or false as a string
    // @description **Description:**
    // @description Scan a library with metaxploit.scan_address using a list of provided vulnerable addresses and return an object containing exploit(s) requirments
    // @description ---
    //
    // @description **Parameters:**
    // @param {list<string>} addressList
    // @description - `addressList`:`list<string>` List of addresses obtained from metaxploit.scan
    // @param {string} libLocation
    // @description - `libLocation`:`string` The locaition of library to scan that the addressess were obtained from
    // @param {map<metaxploitLib>} metaxploitObject
    // @description - `map`:`metaxploitLib` A metaxploitObject
    // @param {flag} [remoteTarget]
    // @description - `remoteTarget`:`flag` Specifiy if the library being scanned locally, or on a remote target
    // @param {number} [targetPort]
    // @description - `targetPort`:`number` Specifiy the port on the remote target
    //
    // @description **Parameter Defaults:**
    // @description - `targetPort`:`false`
    // @description - `targetPort`:`0`
    //
    // @description **Return:**
    // @return {list<maps>}{string}
    // @description `list<maps>`:`<exploitRequirments>`
    // @description - - `.address`
    // @description - - `.variable`
    // @description - - `.cra`
    // @description - - `.cua`
    // @description - - `.cga`
    // @description - - `.rpf`
    // @description - - `.rur`
    // @description - - `.is_patched`
    // @description - - `.version`
    // @description ---
    //    
    // @description **Requires:**
    // @description - `function`:`unsafe_check_list()`@`version`:`0.0.1` or higher
    // @description - `method`:`list.crop`@`version`:`0.0.1` or higher
    // @description ---
    //
    // @description **Author:** Svarii
    // @description **Version:** 0.0.1
    // @description ---
    //
    // @description ***footnotes***   
    // @description Parameters are not checked for validity   
    // @description ---
    //
    // @example scanLibLocation = "/lib/aptclient.so"
    // @example metaxLocation = "/lib/metaxploit.so"
    // @example metax = include_lib(metaxLocation)
    // @example
    // exploitAddressList = find_exploitable_addresses(scanLibLocation, metax)
    // @example
    // exploitReq = fetch_exploit_requirements(exploitAddressList, libLocation, metax)
    // @example
    // print exploitReq[0].address + ":" + exploitReq[0].variable //prints values to be used with metaxploit.scan_address
fetch_exploit_requirements = function(addressList, libLocation, metaxploitObject, remoteTarget = false, targetPort = 0)
    locals.metax = locals.metaxploitObject
    if locals.remoteTarget == false then
		locals.metaLib = locals.metax.load(locals.libLocation)
	else
		locals.metaLib = locals.metax.net_use(locals.libLocation, locals.targetPort)
	end if
    locals.allExploitData = []
    for address in locals.addressList
        locals.scanResults = locals.metax.scan_address(locals.metaLib, locals.address)
        locals.unsafeCheckLists = (globals.unsafe_check_list(locals.scanResults)).crop
        for unsafeCheck in locals.unsafeCheckLists
                locals.exploits = {"classID": "exploitRequirments", "version":version,"is_patched":locals.metaLib.is_patched ,"address": locals.address, "variable": locals.unsafeCheck.extract, "cra": false, "cga": false, "cua": false, "rur": 0, "rpf": 0}
                if not locals.unsafeCheck.indexOf("Checking root active") then
                    locals.exploits.cra = false
                else
                    locals.exploits.cra = true
                end if
                if not locals.unsafeCheck.indexOf("Checking an active user") then
                    locals.exploits.cua = false
                else
                    locals.exploits.cua = true
                end if
                if not locals.unsafeCheck.indexOf("Checking guest active") then
                    locals.exploits.cga = false
                else
                    locals.exploits.cga = true
                end if
					locals.unsafeCheckItems = split(locals.unsafeCheck, char(10))
					for unsafeItem in locals.unsafeCheckItems
						if not locals.unsafeItem.indexOf("to ", ".") == null then
							if not locals.unsafeItem.indexOf("registered users") == null then
			                    locals.exploits.rur = to_int((locals.unsafeItem.extract("to ", ".")).remove_char_last)
							end if
							if not locals.unsafeItem.indexOf("port forwarding") == null then
								locals.portForwards = locals.unsafeItem.remove(" port forwarding configured from router to the target computer.")
			                    locals.exploits.rpf = to_int(((locals.unsafeItem.remove(" port forwarding configured from router to the target computer.")).remove("* ")))
							end if						
						end if
					end for
				locals.exploits.version = locals.metaLib.version
                locals.allExploitData.push(locals.exploits)
            end for
    end for
    return locals.allExploitData
end function
// @startyaml
//
// # ExploitRequirements Class Diagram
// #highlight "ExploitRequirements" / "Meta"
//
// ExploitRequirements:
//   Meta:
//     is_patched: "boolean"
//   Exploit:
//     address: "string"
//     variable: "string"
//     version: "string"
//   Requirements:
//     cra: "boolean"    # Check root is active
//     cua: "boolean"    # Check user is active
//     cga: "boolean"    # Check guest is active
//     rur: "number"     # Required # of users registered
//     rpf: "number"     # Required # of port forwards
//
// # Note:
// # * cra: Check root is active
// # * cua: Check user is active
// # * cga: Check guest is active
// # * Required # of users registered
// # * Required # of port forwards
//
// @endyaml