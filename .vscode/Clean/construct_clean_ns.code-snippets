{
  "construct: fetch_whois": {
    "prefix": "construct_fetch_whois",
    "scope": "greyscript",
    "description": "Insert fetch_whois (clean, header removed).",
    "body": [
      "fetch_whois = function(routerPublicIPAddress)",
      "\tif not is_lan_ip(locals.routerPublicIPAddress) == true then",
      "\t\tif is_valid_ip(routerPublicIPAddress) then",
      "\t\t\tlocals.whoisInfo = {\"classID\":\"whoisInfo\", \"admin\":\"\", \"domain\":\"\", \"email\":\"\", \"network\":\"\", \"phone\":\"\", \"error\":null}",
      "\t\t\tlocals.what = split(whois(locals.routerPublicIPAddress), \"\\n\")",
      "\t\t\tlocals.whoisInfo.domain = str(split(locals.what[0], \":\")[1]).trim",
      "\t\t\tlocals.whoisInfo.admin = str(split(locals.what[1], \":\")[1]).trim",
      "\t\t\tlocals.whoisInfo.email = str(split(locals.what[2], \":\")[1]).trim",
      "\t\t\tlocals.whoisInfo.phone = str(split(locals.what[3], \":\")[1]).trim",
      "\t\t\tif locals.what.len >= 5 then",
      "\t\t\t\tlocals.whoisInfo.network = str(split(locals.what[4], \":\")[0]).trim",
      "\t\t\telse",
      "\t\t\t\tlocals.whoisInfo.network = \"[ UNKNOWN ]\"",
      "\t\t\tend if",
      "\t\telse ",
      "\t\t\tlocals.whoisInfo = {\"classID\":\"whoisInfo\", \"error\":\"Invalid Public IP Address Provided.\"}\t",
      "\t\tend if",
      "\telse",
      "\t\tlocals.whoisInfo = {\"classID\":\"whoisInfo\", \"error\":\"Needs Public IP, Provided Local IP.\"}",
      "\tend if",
      "\tlocals.whoisInfo.error = false",
      "\treturn locals.whoisInfo",
      "end function",
      "",
      "",
      ""
    ]
  },
  "construct: file_location_ident": {
    "prefix": "construct_file_location_ident",
    "scope": "greyscript",
    "description": "Insert file_location_ident (clean, header removed).",
    "body": [
      "file_location_ident = function(absoluteLocation)",
      "        locals.ext = slice(locals.absoluteLocation, (locals.absoluteLocation.lastIndexOf(\".\") + 1), locals.absoluteLocation.len)",
      "        locals.name = slice(locals.absoluteLocation, locals.absoluteLocation.lastIndexOf(\"/\") + 1, locals.absoluteLocation.lastIndexOf(\".\"))",
      "\t\tlocals.filename = locals.name + \".\" + locals.ext",
      "        locals.dir = slice(locals.absoluteLocation, locals.absoluteLocation.indexOf(\"/\"), locals.absoluteLocation.lastIndexOf(\"/\"))",
      "        locals.folder = slice(locals.dir, locals.dir.lastIndexOf(\"/\") + 1)",
      "        locals.location = locals.dir + \"/\" + locals.name + \".\" + locals.ext",
      "        locals.construct = {\"classID\":\"fileID\", \"ext\": locals.ext, \"name\": locals.name, \"parentdir\": locals.folder, \"dir\": locals.dir, \"location\": locals.location, \"filename\": locals.filename}",
      "        return locals.construct",
      "end function",
      "// @startyaml",
      "//",
      "// # File Identifier Class Diagram",
      "// #highlight \"fileID\" / \"File Info\"",
      "//",
      "// fileID:",
      "//   File Info:",
      "//     ext: \"string\"      # File extension",
      "//     name: \"string\"     # Base name of the file",
      "//     filename: \"string\" # Full file name",
      "//   Path Info:",
      "//     dir: \"string\"      # Directory path",
      "//     parentdir: \"string\" # Parent directory",
      "//     location: \"string\"  # Absolute file path",
      "//",
      "// # Note:",
      "// # Extracts and assembles file properties",
      "// # from an absolute location.",
      "//",
      "// @endyaml"
    ]
  },
  "construct: id_self": {
    "prefix": "construct_id_self",
    "scope": "greyscript",
    "description": "Insert id_self (clean, header removed).",
    "body": [
      "id_self = function()",
      "\tlocals.localRouter = get_router",
      "        if not typeof(locals.localRouter) == \"router\" then return \"Failed to fetch local router object.\"",
      "\tlocals.localComputer = get_shell.host_computer",
      "        if not typeof(locals.localComputer) == \"computer\" then return \"Failed to fetch local computer object.\"",
      "\tlocals.ipInformation = {\"classID\": \"ipInformation\", \"local\": locals.localComputer.local_ip, \"public\": locals.localComputer.public_ip, \"gateway\":locals.localComputer.network_gateway}",
      "\tlocals.ipScan = locals.ipInformation",
      "\tlocals.ComputerInformation = {\"classID\": \"computerInformation\",\"name\":locals.localComputer.get_name, \"home\":home_dir, \"location\":program_path, \"path\":current_path, \"user\":active_user, \"has_internet\":locals.localComputer.is_network_active}",
      "\tlocals.computerInfo = locals.ComputerInformation",
      "\tlocals.currentStatus = {\"classID\":\"currentStatus\", \"ipInfo\":locals.ipScan, \"compInfo\":locals.computerInfo}",
      "\tlocals.currentStatus.classID = \"currentStatus\"",
      "\treturn locals.currentStatus",
      "end function",
      "\t// @startuml",
      "\t// title <color:purple>currentStatus Class Diagram</color>",
      "\t// ",
      "\t// class currentStatus {",
      "\t//   .. <color:blue>.compInfo</color> ..",
      "\t//   + .name : string",
      "\t//   + .home : string",
      "\t//   + .location : string",
      "\t//   + .path : string",
      "\t//   + .user : string",
      "\t//   + .has_internet : boolean",
      "\t// ",
      "\t//   .. <color:blue>.ipInfo</color> ..",
      "\t//   + local : string",
      "\t//   + public : string",
      "\t//   + gateway : string",
      "\t// }",
      "\t// ",
      "\t// note right of currentStatus",
      "\t//   * Pulls basic information",
      "\t//      on the immediate environment",
      "\t//   * Populates currentStatus Object",
      "\t// end note",
      "\t// ",
      "\t// @enduml"
    ]
  },
  "construct: fetch_exploit_requirements": {
    "prefix": "construct_fetch_exploit_requirements",
    "scope": "greyscript",
    "description": "Insert fetch_exploit_requirements (clean, header removed).",
    "body": [
      "fetch_exploit_requirements = function(targetAddress, metaLibObject, metaxploitObject)",
      "    locals.metax = locals.metaxploitObject",
      "    locals.metaLib = locals.metaLibObject",
      "    locals.allExploitData = []",
      "    locals.scanResults = locals.metax.scan_address(locals.metaLib, targetAddress)",
      "    locals.unsafeCheckLists = (unsafe_check_list(locals.scanResults)).crop",
      "    for unsafeCheck in locals.unsafeCheckLists",
      "            locals.exploits = {\"classID\": \"exploitRequirments\", \"version\":version, \"address\": targetAddress, \"variable\": locals.unsafeCheck.extract, \"cra\": false, \"cga\": false, \"cua\": false, \"rur\": 0, \"rpf\": 0}",
      "            if not locals.unsafeCheck.indexOf(\"Checking root active\") then",
      "                locals.exploits.cra = false",
      "            else",
      "                locals.exploits.cra = true",
      "            end if",
      "            if not locals.unsafeCheck.indexOf(\"Checking an active user\") then",
      "                locals.exploits.cua = false",
      "            else",
      "                locals.exploits.cua = true",
      "            end if",
      "            if not locals.unsafeCheck.indexOf(\"Checking guest active\") then",
      "                locals.exploits.cga = false",
      "            else",
      "                locals.exploits.cga = true",
      "            end if",
      "                locals.unsafeCheckItems = split(locals.unsafeCheck, char(10))",
      "                locals.unsafeCheckHeader = locals.unsafeCheckItems[0]",
      "                for unsafeItem in locals.unsafeCheckItems",
      "                    if not locals.unsafeItem.indexOf(\"to \", \".\") == null then",
      "                        if not locals.unsafeItem.indexOf(\"registered users\") == null then",
      "                            locals.exploits.rur = to_int((locals.unsafeItem.extract(\"to \", \".\")).remove_char_last)",
      "                        end if  ",
      "                        if not locals.unsafeItem.indexOf(\"port forwarding\") == null then",
      "                            locals.portForwards = locals.unsafeItem.remove(\" port forwarding configured from router to the target computer.\")",
      "                            locals.exploits.rpf = to_int(((locals.unsafeItem.remove(\" port forwarding configured from router to the target computer.\")).remove(\"* \")))",
      "                        end if\t\t\t\t\t\t",
      "                    end if",
      "                end for",
      "            locals.exploits.version = locals.metaLib.version",
      "            locals.allExploitData.push(locals.exploits)",
      "        end for",
      "    return locals.allExploitData",
      "end function",
      "// @startuml",
      "// title <color:purple>ExploitRequirements Class Diagram</color>",
      "//",
      "// class ExploitRequirements {",
      "//   .. <color:blue>Patch Status</color> ..",
      "//   + is_patched : boolean",
      "//",
      "//   .. <color:blue>Target Info</color> ..",
      "//   + address : string",
      "//   + variable : string",
      "//   + version : string",
      "//",
      "//   .. <color:blue>Activation Checks</color> ..",
      "//   + cra : boolean     // root active",
      "//   + cua : boolean     // user active",
      "//   + cga : boolean     // guest active",
      "//",
      "//   .. <color:blue>Thresholds</color> ..",
      "//   + rur : number      // required users registered",
      "//   + rpf : number      // required port forwards",
      "// }",
      "//",
      "// note right of ExploitRequirements",
      "//   * Defines conditions needed for exploit deployment",
      "//   * Includes patch status and system role activity",
      "//   * Thresholds must be met for successful trigger",
      "// end note",
      "//",
      "// @enduml"
    ]
  }
}