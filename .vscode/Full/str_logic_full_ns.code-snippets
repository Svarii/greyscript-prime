{
  "str_logic: extract": {
    "prefix": "strlogic_extract",
    "scope": "greyscript",
    "description": "Insert extract (full, with header).",
    "body": [
      "// Extract the text between the first found indexies of the given start and end strings        ",
      "    // @description **Description:** Extract the text between the first found bold tag if no paramaters provided",
      "    // @description ---",
      "    // @description **Parameters:**",
      "    // @param {string} [tagStart = \"<b>\"\"]",
      "    // @description `tagStart`:`string`",
      "    // @param {string} [tagEnd = \"</b>\"]",
      "    // @description `tagEnd`:`string`",
      "    // @description ---",
      "    // @return {string or null}",
      "    // @example newString = \"<b>0x53C737</b>\"",
      "    // @example result = newString.extract(\"<b>\", \"</b>\")",
      "    // @example print(result); // Output: 0x53C737   ",
      "string.extract = function(tagStart = \"<b>\", tagEnd = \"</b>\")",
      "    locals.startIndex = self.indexOf(locals.tagStart) + (locals.tagStart.len)",
      "    locals.endIndex = (self.indexOf(locals.tagEnd) - (locals.tagEnd.len - locals.tagStart.len)) + 1",
      "    return slice(self, locals.startIndex, locals.endIndex)",
      "end function",
      "// @startuml",
      "    // start",
      "    // :<color:purple>startIndex = tagStart</color>;",
      "    // :<color:purple>endIndex = tagEnd</color>;",
      "    // :<color:green>return slice(self, startIndex, endIndex)</color>;",
      "    // stop",
      "    // @enduml        "
    ]
  },
  "str_logic: format": {
    "prefix": "strlogic_format",
    "scope": "greyscript",
    "description": "Insert format (full, with header).",
    "body": [
      "//  **Description:**",
      "//  Allows for string interpolation using a delimiter (default is \"%s\").",
      "//  @contributer dynobytes",
      "//",
      "//  @param {list<string>} args - List of values to insert into the string.",
      "//  @param {string} [delim=\"%s\"] - Delimiter to identify where values should be inserted.",
      "//",
      "//  @return {string}",
      "//  @description `string` \u2014 Formatted string with values interpolated at delimiter positions.",
      "//",
      "//  @description **Author:** Dynobytes  ",
      "//  @description **Contributer:** Svarii",
      "//  @description **Version:** 0.0.1",
      "//  @description ---",
      "//",
      "//  @example variableString = \"The quick brown %s jumps over the lazy %s\"",
      "//  @example animalsList = [\"fox\", \"dog\"]",
      "//  @example",
      "//  sentence = variableString.format(animalsList)",
      "//  @example",
      "//  print(sentence); // Output: The quick brown fox jumps over the lazy dog",
      "//  @description ---",
      "string.format = function(args, delim=\"%s\")",
      "    locals.splitStr = self.split(locals.delim);",
      "    locals.recompStr = \"\"",
      "    for i in range(0, locals.args.len()-1)",
      "        locals.recompStr = locals.recompStr + locals.splitStr[locals.i] + locals.args[locals.i]  ",
      "    end for",
      "        locals.recompStr = locals.recompStr + locals.splitStr[locals.splitStr.len()-1]",
      "    return locals.recompStr",
      "end function",
      "    // @startuml",
      "    // start",
      "    // :<color:purple>splitStr = self.split(delim)</color>;",
      "    // :<color:purple>recompStr = \"\"</color>;",
      "    // :<color:blue>For i = 0 to args.len()-1</color>;",
      "    // repeat",
      "    //   :<color:purple>recompStr = recompStr + splitStr[i] + args[i]</color>;",
      "    // repeat while (next i exists)",
      "    // :<color:purple>recompStr = recompStr + splitStr[splitStr.len()-1]</color>;",
      "    // :<color:green>return recompStr</color>;",
      "    // stop",
      "    // @enduml"
    ]
  },
  "str_logic: mask": {
    "prefix": "strlogic_mask",
    "scope": "greyscript",
    "description": "Insert mask (full, with header).",
    "body": [
      "// Detects and masks ipv4 addresses found in string",
      "// @description **Description**",
      "// @description Optionally detects and masks ipv4 addresses found in string.",
      "// @description Custom character and color supported",
      "// @description ---",
      "//",
      "// @param {boolean}[maskString]",
      "// @param {char}[maskChar]",
      "// @param {string}[maskColor]",
      "// @description",
      "//",
      "// @description **Default Parameters:**",
      "// @description - `maskString == true`",
      "// @description - `maskChar == *`",
      "// @description - `maskColor == null`",
      "//",
      "// @return {string}",
      "// @description **Return**",
      "// `string`",
      "// @description ---    ",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Contibutor:** GrinCulus",
      "// @description **Version:** 0.0.3",
      "// @description ---    ",
      "//",
      "// @description **Notes:**",
      "// @description - `maskColor` Accepted format: `#RRGGBB` | `#RRGGBBAA`",
      "//",
      "// @example myString = \"192.168.0.1 is the router for computer 211.131.5.1\"",
      "// @example",
      "// print myString.mask              //Output *********** is the router for computer ***********",
      "// @example",
      "// print myString.mask(true, \"x\")   //Output xxxxxxxxxxx is the router for computer xxxxxxxxxxx",
      "// @example",
      "// print myString.mask(false)       //Output \"192.168.0.1 is the router for computer 211.131.5.1\"",
      "string.mask = function(maskString = true, maskChar = char(42), maskColor = null)",
      "    if not maskColor == null then maskChar = \"<\" + maskColor + \">\" + maskChar + \"</color>\"",
      "    locals.ipPattern = \"\\b(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d).){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\b\"",
      "    locals.matchList = self.matches(locals.ipPattern)",
      "    locals.newString = \"\"",
      "    if locals.maskString == false then return self",
      "    if locals.matchList.len > 0 then",
      "        locals.newString = self",
      "        for match in locals.matchList",
      "            locals.newString = locals.newString.replace(locals.match.value, maskChar*locals.match.value.len)",
      "        end for",
      "        return locals.newString",
      "    else",
      "        return self",
      "    end if",
      "end function"
    ]
  }
}