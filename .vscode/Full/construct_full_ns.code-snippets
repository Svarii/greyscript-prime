{
  "construct: fetch_whois": {
    "prefix": "construct_fetch_whois",
    "scope": "greyscript",
    "description": "Insert fetch_whois (full, with header).",
    "body": [
      "// @startuml",
      "// title <color:purple>fetch_whois Function Overview</color>",
      "//",
      "// class fetch_whois {",
      "//   .. <color:blue>Input</color> ..",
      "//   + routerPublicIPAddress : string",
      "//",
      "//   .. <color:blue>Return</color> ..",
      "//   + returns : whoisInfo",
      "// }",
      "//",
      "// class whoisInfo {",
      "//   .. <color:blue>Standard Whois Fields</color> ..",
      "//   + admin : string",
      "//   + domain : string",
      "//   + email : string",
      "//   + phone : string",
      "//   + network : string",
      "//",
      "//   .. <color:blue>Error Handling</color> ..",
      "//   + error : string",
      "// }",
      "//",
      "// fetch_whois -right-> whoisInfo : creates instance of",
      "//",
      "// note bottom of whoisInfo",
      "//   * Contains IP registration and contact metadata",
      "//   * Fields populated from WHOIS lookup",
      "//   * On error, only `.error` is set",
      "// end note",
      "//",
      "// note bottom of fetch_whois",
      "//   * Validates that IP is public and well-formed",
      "//   * Rejects LAN addresses and malformed input",
      "//   * Uses `whois()` to extract structured details",
      "// end note",
      "//",
      "// @enduml",
      "",
      "// Pull whosis information from a public ip address",
      "\t// @description **Description:**",
      "\t// Return map with whois information",
      "\t// @description ---",
      "\t//",
      "\t// @description **Parameters:**",
      "\t// @param {string} routerPublicIPAddress",
      "\t// @description - `routerPublicIPAddress`:`<string>`",
      "\t//",
      "\t// @description **Parameter Defaults:**",
      "\t// @description - `none`",
      "\t//",
      "\t// @description **Return:**",
      "\t// @return {map<string,string>}",
      "\t// @description `map`:`whoisInfo`",
      "\t// @description - `.admin`:`<string>` The administrative contacts' name",
      "\t// @description - `.domain`:`<string>` The domain name of the ip address",
      "\t// @description - `.email`:`<string>` The email address for the administrative contact",
      "\t// @description - `.network`:`<string>` The network identifier (if any)",
      "\t// @description - `.phone`:`<string>` The phone number for the administrative contract",
      "\t// @description ---\t",
      "\t// @description - - `.error`:`<string>` {on error} will return obect with only this property",
      "\t// @description ---",
      "\t//    ",
      "\t// @description **Author:** Svarii",
      "\t// @description **Version:** 0.0.1",
      "\t// @description ---",
      "\t// ",
      "\t// @example whoisInfo = fetch_whois(params[0])",
      "\t// @example",
      "\t// print whoisInfo.domain",
      "\t// @example",
      "\t// print whoisInfo.admin",
      "\t// @example",
      "\t// print whoisInfo.email",
      "\t// @example",
      "\t// print whoisInfo.phone",
      "\t// @example",
      "\t// print whoisInfo.network",
      "fetch_whois = function(routerPublicIPAddress)",
      "\tif not is_lan_ip(locals.routerPublicIPAddress) == true then",
      "\t\tif is_valid_ip(routerPublicIPAddress) then",
      "\t\t\tlocals.whoisInfo = {\"classID\":\"whoisInfo\", \"admin\":\"\", \"domain\":\"\", \"email\":\"\", \"network\":\"\", \"phone\":\"\", \"error\":null}",
      "\t\t\tlocals.what = split(whois(locals.routerPublicIPAddress), \"\\n\")",
      "\t\t\tlocals.whoisInfo.domain = str(split(locals.what[0], \":\")[1]).trim",
      "\t\t\tlocals.whoisInfo.admin = str(split(locals.what[1], \":\")[1]).trim",
      "\t\t\tlocals.whoisInfo.email = str(split(locals.what[2], \":\")[1]).trim",
      "\t\t\tlocals.whoisInfo.phone = str(split(locals.what[3], \":\")[1]).trim",
      "\t\t\tif locals.what.len >= 5 then",
      "\t\t\t\tlocals.whoisInfo.network = str(split(locals.what[4], \":\")[0]).trim",
      "\t\t\telse",
      "\t\t\t\tlocals.whoisInfo.network = \"[ UNKNOWN ]\"",
      "\t\t\tend if",
      "\t\telse ",
      "\t\t\tlocals.whoisInfo = {\"classID\":\"whoisInfo\", \"error\":\"Invalid Public IP Address Provided.\"}\t",
      "\t\tend if",
      "\telse",
      "\t\tlocals.whoisInfo = {\"classID\":\"whoisInfo\", \"error\":\"Needs Public IP, Provided Local IP.\"}",
      "\tend if",
      "\tlocals.whoisInfo.error = false",
      "\treturn locals.whoisInfo",
      "end function",
      "",
      "",
      ""
    ]
  },
  "construct: file_location_ident": {
    "prefix": "construct_file_location_ident",
    "scope": "greyscript",
    "description": "Insert file_location_ident (full, with header).",
    "body": [
      "// Returns an file identifier construct",
      "    // @description **Description:**",
      "    // @description Creats an object construct and populates it with file identification attributes",
      "    // @description ---",
      "    //",
      "    // @description **Parameters:**",
      "    // @param {string} absoluteLocation",
      "    // @description - `absoluteLocation`:`<string>`",
      "    //",
      "    // @description **Parameter Defaults:**",
      "    // @description - `none`",
      "    //",
      "    // @description **Return:**",
      "    // @return {map<string,string>}",
      "    // @description `map`:`fileID` populated with file identifer information",
      "    // @description - `.ext`",
      "    // @description - `.name`",
      "    // @description - `.filename`",
      "    // @description - `.dir`",
      "    // @description - `.parentdir`",
      "    // @description - `.location`",
      "    // @description ---",
      "    //    ",
      "    // @description **Author:** Svarii",
      "    // @description **Version:** 0.0.1",
      "    // @description ---",
      "    //",
      "    // @description ***footnotes***   ",
      "    // @description Parameters are not checked for validity   ",
      "    // @description - `absoluteLocation`:`<number>` will result in \"Runtime Error: Key Not Found: 'lastIndexOf' not found in map \"",
      "    // @description - `absoluteLocation`:`<map>` will result in \"Runtime Error: Key Not Found: 'lastIndexOf' not found in map \"",
      "    // @description ---        ",
      "    //",
      "    // @example aptClientID = file_location_ident(\"/lib/aptclient.so\")",
      "    // @example",
      "    // print(aptClientID.filename); // Output: aptclient.so",
      "    // @example",
      "    // print(aptClientID.location); // Output: /lib/aptclient.so",
      "    // @example",
      "    // print(aptClientID.ext); // Output: so",
      "    // @example",
      "    // print(aptClientID.name); // Output: aptclient",
      "file_location_ident = function(absoluteLocation)",
      "        locals.ext = slice(locals.absoluteLocation, (locals.absoluteLocation.lastIndexOf(\".\") + 1), locals.absoluteLocation.len)",
      "        locals.name = slice(locals.absoluteLocation, locals.absoluteLocation.lastIndexOf(\"/\") + 1, locals.absoluteLocation.lastIndexOf(\".\"))",
      "\t\tlocals.filename = locals.name + \".\" + locals.ext",
      "        locals.dir = slice(locals.absoluteLocation, locals.absoluteLocation.indexOf(\"/\"), locals.absoluteLocation.lastIndexOf(\"/\"))",
      "        locals.folder = slice(locals.dir, locals.dir.lastIndexOf(\"/\") + 1)",
      "        locals.location = locals.dir + \"/\" + locals.name + \".\" + locals.ext",
      "        locals.construct = {\"classID\":\"fileID\", \"ext\": locals.ext, \"name\": locals.name, \"parentdir\": locals.folder, \"dir\": locals.dir, \"location\": locals.location, \"filename\": locals.filename}",
      "        return locals.construct",
      "end function",
      "// @startyaml",
      "//",
      "// # File Identifier Class Diagram",
      "// #highlight \"fileID\" / \"File Info\"",
      "//",
      "// fileID:",
      "//   File Info:",
      "//     ext: \"string\"      # File extension",
      "//     name: \"string\"     # Base name of the file",
      "//     filename: \"string\" # Full file name",
      "//   Path Info:",
      "//     dir: \"string\"      # Directory path",
      "//     parentdir: \"string\" # Parent directory",
      "//     location: \"string\"  # Absolute file path",
      "//",
      "// # Note:",
      "// # Extracts and assembles file properties",
      "// # from an absolute location.",
      "//",
      "// @endyaml"
    ]
  },
  "construct: id_self": {
    "prefix": "construct_id_self",
    "scope": "greyscript",
    "description": "Insert id_self (full, with header).",
    "body": [
      "// Generate currentStatus Object",
      "\t// @description **Description:**",
      "\t// Generate an object that contains basic environment information",
      "\t// @description ---",
      "\t//",
      "\t// @description **Parameters:**",
      "\t// @description - none ",
      "\t// @description ---",
      "\t//",
      "\t// @description **Return:**",
      "\t// @return {map<string,maps>} - System Object {.shell and .computer}",
      "\t// @description `computerStatus`:`<maps><string>` currentStatus Object",
      "\t// @description - `.compInfo` - computerInformation Object",
      "\t// @description - - `.name`",
      "\t// @description - - `.home`",
      "\t// @description - - `.location`",
      "\t// @description - - `.path`\t",
      "\t// @description - - `.user`\t",
      "\t// @description - - `.has_internet`",
      "\t// @description - `.ipInfo` - ipInformation Object",
      "\t// @description - - `.local`",
      "\t// @description - - `.public`",
      "\t// @description - - `.gateway`\t",
      "\t// @description ---   ",
      "\t//    ",
      "\t//  @example iScan = new id_self",
      "\t//  @example print typeof(iScan)  //Output: currentStatus",
      "\t//  @example ",
      "\t//  @example\tprint iScan.compInfo.name  //Output: The name of the computer",
      "\t//  @example\tprint iScan.compInfo.has_internet  //Output: boolean 1 or 0",
      "\t//  @example\tprint iScan.ipInfo.public  //Output: public ip of computer",
      "id_self = function()",
      "\tlocals.localRouter = get_router",
      "        if not typeof(locals.localRouter) == \"router\" then return \"Failed to fetch local router object.\"",
      "\tlocals.localComputer = get_shell.host_computer",
      "        if not typeof(locals.localComputer) == \"computer\" then return \"Failed to fetch local computer object.\"",
      "\tlocals.ipInformation = {\"classID\": \"ipInformation\", \"local\": locals.localComputer.local_ip, \"public\": locals.localComputer.public_ip, \"gateway\":locals.localComputer.network_gateway}",
      "\tlocals.ipScan = locals.ipInformation",
      "\tlocals.ComputerInformation = {\"classID\": \"computerInformation\",\"name\":locals.localComputer.get_name, \"home\":home_dir, \"location\":program_path, \"path\":current_path, \"user\":active_user, \"has_internet\":locals.localComputer.is_network_active}",
      "\tlocals.computerInfo = locals.ComputerInformation",
      "\tlocals.currentStatus = {\"classID\":\"currentStatus\", \"ipInfo\":locals.ipScan, \"compInfo\":locals.computerInfo}",
      "\tlocals.currentStatus.classID = \"currentStatus\"",
      "\treturn locals.currentStatus",
      "end function",
      "\t// @startuml",
      "\t// title <color:purple>currentStatus Class Diagram</color>",
      "\t// ",
      "\t// class currentStatus {",
      "\t//   .. <color:blue>.compInfo</color> ..",
      "\t//   + .name : string",
      "\t//   + .home : string",
      "\t//   + .location : string",
      "\t//   + .path : string",
      "\t//   + .user : string",
      "\t//   + .has_internet : boolean",
      "\t// ",
      "\t//   .. <color:blue>.ipInfo</color> ..",
      "\t//   + local : string",
      "\t//   + public : string",
      "\t//   + gateway : string",
      "\t// }",
      "\t// ",
      "\t// note right of currentStatus",
      "\t//   * Pulls basic information",
      "\t//      on the immediate environment",
      "\t//   * Populates currentStatus Object",
      "\t// end note",
      "\t// ",
      "\t// @enduml"
    ]
  },
  "construct: fetch_exploit_requirements": {
    "prefix": "construct_fetch_exploit_requirements",
    "scope": "greyscript",
    "description": "Insert fetch_exploit_requirements (full, with header).",
    "body": [
      "    // Return true or false as a string",
      "    // @description **Description:**",
      "    // @description Scan a library with metaxploit.scan_address using a list of provided vulnerable addresses and return an object containing exploit(s) requirments",
      "    // @description ---",
      "    //",
      "    // @description **Parameters:**",
      "    // @param {list<string>} addressList",
      "    // @description - `addressList`:`list<string>` List of addresses obtained from metaxploit.scan",
      "    // @param {map<metaLibObject>} metaLibObject",
      "    // @description - `map`:`metaLibObject` A MetaLib Object",
      "    // @param {map<metaxploitLib>} metaxploitObject",
      "    // @description - `map`:`metaxploitLib` A MetaxploitLib Object",
      "    //",
      "    // @description **Parameter Defaults:**",
      "    // @description - `none`",
      "    //",
      "    // @description **Return:**",
      "    // @return {list<maps>}{string}",
      "    // @description `list<maps>`:`<exploitRequirments>`",
      "    // @description - - `.address`",
      "    // @description - - `.variable`",
      "    // @description - - `.cra`",
      "    // @description - - `.cua`",
      "    // @description - - `.cga`",
      "    // @description - - `.rpf`",
      "    // @description - - `.rur`",
      "    // @description - - `.version`",
      "    // @description ---",
      "    //    ",
      "    // @description **Requires:**",
      "    // @description - `function`:`unsafe_check_list()`@`version`:`0.0.1` or higher",
      "    // @description - `method`:`list.crop`@`version`:`0.0.1` or higher",
      "    // @description ---",
      "    //",
      "    // @description **Author:** Svarii",
      "    // @description **Version:** 0.0.1",
      "    // @description ---",
      "    //",
      "    // @description ***footnotes***   ",
      "    // @description Parameters are not checked for validity   ",
      "    // @description ---",
      "    //",
      "    // @example scanLibLocation = \"/lib/aptclient.so\"",
      "    // @example metaxLocation = \"/lib/metaxploit.so\"",
      "    // @example metax = include_lib(metaxLocation)",
      "    // @example",
      "    // exploitAddressList = find_exploitable_addresses(scanLibLocation, metax)",
      "    // @example",
      "    // exploitReq = fetch_exploit_requirements(exploitAddressList, libLocation, metax)",
      "    // @example",
      "    // print exploitReq[0].address + \":\" + exploitReq[0].variable //prints values to be used with metaxploit.scan_address",
      "fetch_exploit_requirements = function(targetAddress, metaLibObject, metaxploitObject)",
      "    locals.metax = locals.metaxploitObject",
      "    locals.metaLib = locals.metaLibObject",
      "    locals.allExploitData = []",
      "    locals.scanResults = locals.metax.scan_address(locals.metaLib, targetAddress)",
      "    locals.unsafeCheckLists = (unsafe_check_list(locals.scanResults)).crop",
      "    for unsafeCheck in locals.unsafeCheckLists",
      "            locals.exploits = {\"classID\": \"exploitRequirments\", \"version\":version, \"address\": targetAddress, \"variable\": locals.unsafeCheck.extract, \"cra\": false, \"cga\": false, \"cua\": false, \"rur\": 0, \"rpf\": 0}",
      "            if not locals.unsafeCheck.indexOf(\"Checking root active\") then",
      "                locals.exploits.cra = false",
      "            else",
      "                locals.exploits.cra = true",
      "            end if",
      "            if not locals.unsafeCheck.indexOf(\"Checking an active user\") then",
      "                locals.exploits.cua = false",
      "            else",
      "                locals.exploits.cua = true",
      "            end if",
      "            if not locals.unsafeCheck.indexOf(\"Checking guest active\") then",
      "                locals.exploits.cga = false",
      "            else",
      "                locals.exploits.cga = true",
      "            end if",
      "                locals.unsafeCheckItems = split(locals.unsafeCheck, char(10))",
      "                locals.unsafeCheckHeader = locals.unsafeCheckItems[0]",
      "                for unsafeItem in locals.unsafeCheckItems",
      "                    if not locals.unsafeItem.indexOf(\"to \", \".\") == null then",
      "                        if not locals.unsafeItem.indexOf(\"registered users\") == null then",
      "                            locals.exploits.rur = to_int((locals.unsafeItem.extract(\"to \", \".\")).remove_char_last)",
      "                        end if  ",
      "                        if not locals.unsafeItem.indexOf(\"port forwarding\") == null then",
      "                            locals.portForwards = locals.unsafeItem.remove(\" port forwarding configured from router to the target computer.\")",
      "                            locals.exploits.rpf = to_int(((locals.unsafeItem.remove(\" port forwarding configured from router to the target computer.\")).remove(\"* \")))",
      "                        end if\t\t\t\t\t\t",
      "                    end if",
      "                end for",
      "            locals.exploits.version = locals.metaLib.version",
      "            locals.allExploitData.push(locals.exploits)",
      "        end for",
      "    return locals.allExploitData",
      "end function",
      "// @startuml",
      "// title <color:purple>ExploitRequirements Class Diagram</color>",
      "//",
      "// class ExploitRequirements {",
      "//   .. <color:blue>Patch Status</color> ..",
      "//   + is_patched : boolean",
      "//",
      "//   .. <color:blue>Target Info</color> ..",
      "//   + address : string",
      "//   + variable : string",
      "//   + version : string",
      "//",
      "//   .. <color:blue>Activation Checks</color> ..",
      "//   + cra : boolean     // root active",
      "//   + cua : boolean     // user active",
      "//   + cga : boolean     // guest active",
      "//",
      "//   .. <color:blue>Thresholds</color> ..",
      "//   + rur : number      // required users registered",
      "//   + rpf : number      // required port forwards",
      "// }",
      "//",
      "// note right of ExploitRequirements",
      "//   * Defines conditions needed for exploit deployment",
      "//   * Includes patch status and system role activity",
      "//   * Thresholds must be met for successful trigger",
      "// end note",
      "//",
      "// @enduml"
    ]
  }
}