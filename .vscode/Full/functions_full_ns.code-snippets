{
  "functions: file_delete": {
    "prefix": "fn_file_delete",
    "scope": "greyscript",
    "description": "Insert file_delete (full, with header).",
    "body": [
      "// Delete a file",
      "// @description **Description:**",
      "// @description Delete a specified file if it has write permissions",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} filePath",
      "// @description - `filePath`:`<string>`",
      "// @param {string} `fileName`:`<string>`",
      "// @description - `fileName`:`<string>`",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `none`",
      "//",
      "// @description **Return:**",
      "// @return {boolean}",
      "// @description `boolean` `true`|`false` This indicates whether write permission could be found, this does not verify delete.",
      "// @description ---",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---",
      "//",
      "// @description ***footnotes***   ",
      "// @description Only checks for write permission, does not verify file exists, or delete was sucessful  ",
      "// @description Parameters are not checked for validity   ",
      "// @description ---        ",
      "//",
      "// @example",
      "// file_delete(\"/DatabaseDir\", \"addressData.db\") //Deletes a file if write permission exists",
      "// @description ---  ",
      "\tfile_delete = function(filePath, fileName)",
      "\t\tlocals.hostComputer = get_shell.host_computer",
      "\t\tlocals.fileLocation = locals.filePath + \"/\" + locals.fileName",
      "\t\tlocals.fileObj = locals.hostComputer.File(locals.fileLocation)",
      "\t\tif locals.fileObj.has_permission(\"w\") then",
      "\t\t\tlocals.hostComputer.File.delete",
      "\t\t\treturn true",
      "\t\tend if",
      "\t\treturn false",
      "\tend function"
    ]
  },
  "functions: file_exists": {
    "prefix": "fn_file_exists",
    "scope": "greyscript",
    "description": "Insert file_exists (full, with header).",
    "body": [
      "// Look for a file",
      "// @description **Description:**",
      "// @description Check to see if the specified file exists",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} filePath",
      "// @description - `filePath`:`<string>`",
      "// @param {string} `fileName`:`<string>`",
      "// @description - `fileName`:`<string>`",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `none`",
      "//",
      "// @description **Return:**",
      "// @return {boolean}",
      "// @description `boolean`:`true`|`false`",
      "// @description ---",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---",
      "//",
      "// @description ***footnotes***   ",
      "// @description Parameters are not checked for validity   ",
      "// @description ---        ",
      "//",
      "// @example",
      "// file_exists(\"/DatabaseDir\", \"addressData.db\") // return true if found, otherwise false",
      "// @description ---  \t\t",
      "\tfile_exists = function(filePath, fileName)",
      "\t\tlocals.hostComputer = get_shell.host_computer",
      "\t\tlocals.fileLocation = locals.filePath + \"/\" + locals.fileName",
      "\t\tlocals.fileObj = locals.hostComputer.File(locals.fileLocation)",
      "\t\tif not locals.fileObj then",
      "\t\t\treturn false",
      "\t\telse",
      "\t\t\treturn true",
      "\t\tend if\t\t",
      "\tend function"
    ]
  },
  "functions: file_new": {
    "prefix": "fn_file_new",
    "scope": "greyscript",
    "description": "Insert file_new (full, with header).",
    "body": [
      "// Create a new file",
      "// @description **Description:**",
      "// @description Create a new file at the specified path if it does not already exist",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} filePath",
      "// @description - `filePath`:`<string>`",
      "// @param {string} `fileName`:`<string>`",
      "// @description - `fileName`:`<string>`",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `none`",
      "//",
      "// @description **Return:**",
      "// @return {void}",
      "// @description `void`",
      "// @description ---",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---",
      "//",
      "// @description ***footnotes***   ",
      "// @description file permissions are not checked",
      "// @description Parameters are not checked for validity   ",
      "// @description ---        ",
      "//",
      "// @example",
      "// file_new(\"/DatabaseDir\", \"addressData.db\") //Creates a file at the specified location",
      "// @description ---  \t",
      "\tfile_new = function(filePath, fileName)",
      "\t\tlocals.hostComputer = get_shell.host_computer",
      "\t\tlocals.fileLocation = locals.filePath + \"/\" + locals.fileName",
      "\t\tlocals.fileObj = locals.hostComputer.File(locals.fileLocation)",
      "\t\tif not locals.fileObj then",
      "\t\t\tlocals.hostComputer.touch(locals.filePath, locals.fileName)",
      "\t\t\tlocals.fileObj = locals.hostComputer.File(locals.fileLocation)",
      "\t\tend if",
      "\t\tif locals.fileObj then",
      "\t\t\treturn true",
      "\t\telse",
      "\t\t\treturn false",
      "\t\tend if",
      "\tend function",
      "// @startuml",
      "// start",
      "// :<color:purple>hostComputer = get_shell.host_computer</color>;",
      "// :<color:purple>fileLocation = filePath + \"/\" + fileName</color>;",
      "// :<color:purple>fileObj = hostComputer.File(fileLocation)</color>;",
      "// if (<color:blue>fileObj does not exist?</color>) then (<color:red>Yes</color>)",
      "//   :<color:purple>hostComputer.touch(filePath, fileName)</color>;",
      "//   :<color:purple>fileObj = hostComputer.File(fileLocation)</color>;",
      "// endif",
      "// if (<color:blue>fileObj exists?</color>) then (<color:green>Yes</color>)",
      "//   :<color:purple>return true</color>;",
      "//   stop",
      "// else (<color:green>No</color>)",
      "//   :<color:purple>return false</color>;",
      "//   stop",
      "// endif",
      "// @enduml\t"
    ]
  },
  "functions: force_params": {
    "prefix": "fn_force_params",
    "scope": "greyscript",
    "description": "Insert force_params (full, with header).",
    "body": [
      "// @startuml",
      "// start",
      "// if (<color:blue>params.len < 1?</color>) then (<color:red>Yes</color>)",
      "//   :<color:purple>exit / print usage</color>;",
      "//   stop",
      "// else (<color:green>No</color>)",
      "// endif",
      "// if (<color:blue>params[0] == \"-h\" or params[0] == \"--help\"?</color>) then (<color:red>Yes</color>)",
      "//   :<color:purple>exit usage</color>;",
      "//   stop",
      "// else (<color:green>No</color>)",
      "// endif",
      "// if (<color:blue>params.len &lt; minReqParams?</color>) then (<color:red>Yes</color>)",
      "//   :<color:purple>exit usage</color>;",
      "//   stop",
      "// else (<color:green>No</color>)",
      "// endif",
      "// stop",
      "// @enduml",
      "",
      "// Require user to pass parameters",
      "// @description **Description:**",
      "// @description Specifies Usage Information and number of required paramters.",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} usage - The name of the library to load.",
      "// @description - `usage`:`<string>`",
      "// @param {number} minReqParams - The directory where the library is located.",
      "// @description - `minReqParams`:`<number>`",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `none`",
      "//",
      "// @description **Return:**",
      "// @return {void}",
      "// @example",
      "// force_params(\"myApp [ipAddress] [port#]\", 2)",
      "// @description ---",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "\tforce_params = function(usage, minReqParams)",
      "\t\tif globals.params.len < 1 then exit locals.usage",
      "\t\tif globals.params[0] == \"-h\" or globals.params[0] == \"--help\" then exit locals.usage",
      "\t\tif globals.params.len < locals.minReqParams then exit locals.usage",
      "\tend function"
    ]
  },
  "functions: get_acks": {
    "prefix": "fn_get_acks",
    "scope": "greyscript",
    "description": "Insert get_acks (full, with header).",
    "body": [
      "// **Description:**",
      "// Caculates the recommended amount of ACKs to collect",
      "// @param {number} signalStrength - `signlaStrength`:`number`",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} signalStrength - The name of the library to load.",
      "// @description - `signalStrength`:`number`",
      "// @description ---",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `signalStrength`:`1`",
      "// @description ---   ",
      "//",
      "// @description **Return:**",
      "// @return {number}",
      "// @description `number` Recommended number of ACKs to collect",
      "// @description ---   ",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "//",
      "// @example reqACK = calculate_acks(6) // Signal Strength 6%",
      "// @example",
      "// print(reqACK) // Output: 14286",
      "\tget_acks = function(signalStrength = 1)",
      "\t\tif not typeof(locals.signalStrength) == \"number\" then",
      "\t\t\tlocals.removePercent = locals.signalStrength.remove(\"%\") //check for % in number string",
      "\t\t\tlocals.newNumber = typeof(to_int(locals.removePercent))",
      "\t\t\tif not locals.newNumber == \"number\" then return null ",
      "\t\t\tif locals.newNumber < 0 then return null",
      "\t\t\tif locals.newNumber > 100 then return null",
      "\t\t\tlocals.signalStrength = locals.newNumber",
      "\t\tend if",
      "\t\tif locals.signalStrength <= 0 or locals.signalStrength > 100 then return null",
      "\t\treturn ceil(300000 / (locals.signalStrength + 15))",
      "\tend function",
      "// @startuml",
      "// start",
      "// :<color:purple>signalStrength = 1 (default)</color>;",
      "// if (<color:blue>is signalStrength a number?</color>) then (<color:red>No</color>)",
      "//   :<color:red>return <b>null</b></color>;",
      "//   stop",
      "// else (<color:green>Yes</color>)",
      "// endif",
      "// if (<color:blue>is signalStrength > 0 and <= 100?</color>) then (<color:red>No</color>)",
      "//   :<color:red>return <b>null</b></color>;",
      "//   stop",
      "// else (<color:green>Yes</color>)",
      "// endif",
      "// :<color:purple>numofACK = ceil(300000 / signalStrength)</color>;",
      "// :<color:green>return <b>numofACK</b></color>;",
      "// stop",
      "// @enduml"
    ]
  },
  "functions: get_exploit_address_list": {
    "prefix": "fn_get_exploit_address_list",
    "scope": "greyscript",
    "description": "Insert get_exploit_address_list (full, with header).",
    "body": [
      "// Find Vulnerable Addresses",
      "// @description **Description:**",
      "// @description Scan a library for vulnerable addresses",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} libLocation",
      "// @description - `libLocation`:`<string>` Remote IP Address or local absolute file location",
      "// @param {map<string,function>} `metaxploitObject`:`<metaxploitLib>`",
      "// @description - `metaxploitObject`:`<metaxploitLib>`",
      "// @param {flag} [remoteTarget]",
      "// @description - `remoteTarget`:`<flag>`",
      "// @param {number} [targetPort]",
      "// @description - `targetPort`:`<number>`",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `remoteTarget`:`false`",
      "// @description - `targetPort`:`0`",
      "//",
      "// @description **Return:**",
      "// @return {list<string>}",
      "// @description `list`",
      "// @description ---",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description --- ",
      "//",
      "// @example libLocation = params[0]",
      "// @example metax = include_lib(\"/lib/metaxploit.so\")",
      "// @example",
      "// print get_exploit_address_list(libLocation, metax)",
      "get_exploit_address_list = function(libLocation, metaxploitObject, remoteTarget = false, targetPort = 0)",
      "    locals.metax = locals.metaxploitObject",
      "\t\tif locals.remoteTarget == false then",
      "        \tlocals.metaLib = locals.metax.load(locals.libLocation)",
      "\t\telse",
      "\t\t\tlocals.netSession = locals.metax.net_use(locals.libLocation, locals.targetPort)",
      "\t\t\tlocals.metaLib = locals.netSession.dump_lib",
      "\t\tend if",
      "\t\tlocals.libScanResult = locals.metax.scan(locals.metaLib)",
      "        return locals.libScanResult",
      "end function",
      "// @startuml",
      "// start",
      "// :<color:purple>metax = metaxploitObject</color>;",
      "// if (<color:blue>remoteTarget == false?</color>) then (<color:green>Yes</color>)",
      "//   :<color:purple>metaLib = metax.load(libLocation)</color>;",
      "// else (<color:green>No</color>)",
      "//   :<color:purple>metaLib = metax.net_use(libLocation, to_int(targetPort))</color>;",
      "// endif",
      "// :<color:purple>libScanResult = metax.scan(metaLib)</color>;",
      "// :<color:green>return libScanResult</color>;",
      "// stop",
      "// @enduml"
    ]
  },
  "functions: bool_text": {
    "prefix": "fn_bool_text",
    "scope": "greyscript",
    "description": "Insert bool_text (full, with header).",
    "body": [
      "        // Return true or false as a string",
      "        // @description **Description:**",
      "        // @description Convert a boolean value **(`true`|`false`)** | **(`0`|`1`)** into `<string>`: `\"true\"`|`\"false\"`",
      "        // @description ---",
      "        //",
      "        // @description **Parameters:**",
      "        // @param {flag} boolVal",
      "        // @description - `boolVal`:`<flag>`",
      "        //",
      "        // @description **Parameter Defaults:**",
      "        // @description - `none`",
      "        //",
      "        // @description **Return:** `string`: `\"true\"` | `\"false\"`",
      "        // @return {string}",
      "        // @description ---",
      "        //    ",
      "        // @description **Author:** Svarii",
      "        // @description **Version:** 0.0.1",
      "        // @description ---",
      "        //",
      "        // @description ***footnotes***   ",
      "        // @description Parameters are not checked for validity   ",
      "        // @description - Any invalid values passed will return `null`",
      "        // @description - Negative numbers will return `\"false\"`",
      "        // @description ---        ",
      "        //",
      "        // @example ",
      "        // print (bool_text(\"true\")) //Output: null",
      "        // @example",
      "        // print (bool_text(true)) //Output: \"true\"",
      "        // @example",
      "        // print (bool_text(1)) //Output: \"true\"",
      "        // @example",
      "        // print (bool_text(0)) //Output: \"false\"",
      "        // @example",
      "        // print (bool_text(-1)) //Output: \"false\"",
      "        // @example",
      "        // print (bool_text(false)) //Output: \"false\"",
      "        // @example",
      "        // print (bool_text(object)) //Output: null",
      "bool_text = function(boolVal, text = [\"true\", \"false\"])",
      "        locals.boolText = {\"yes\":\"false\", \"no\":\"false\"}",
      "        if locals.boolVal < 0 then return locals.boolText.no",
      "        if locals.boolVal > 1 then return locals.boolText.yes",
      "        if locals.boolVal == 1 then return locals.boolText.yes",
      "        if locals.boolVal == 0 then return locals.boolText.no",
      "    return null",
      "end function"
    ]
  },
  "functions: display_menu": {
    "prefix": "fn_display_menu",
    "scope": "greyscript",
    "description": "Insert display_menu (full, with header).",
    "body": [
      "// Highlight list item",
      "// @description **Description:**",
      "// @description Add a highlight to the specificed list index",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {list<string>} menuList",
      "// @param {number} selectedItem",
      "// @param {string} [highlightcolor]",
      "// @param {string} [textColor]",
      "//",
      "// @description - `menuList`:`<list><string>`",
      "// @description - `selectedItem`:`<number>`",
      "// @description - `highlightcolor`:`<#HEXA / #RRGGBBAA>`",
      "// @description - `textColor`:`<string>`",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `highlightcolor`:`#FFFF002C`",
      "//",
      "// @description **Return:**",
      "// @return {list<string>}",
      "// @description `list` List with marked index",
      "// @description ---",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---   ",
      "display_menu = function(menuList, selectedItem, highlightcolor = \"#FFFF002C\", textColor = null)",
      "    locals.outputMenu = []",
      "    for menuItem in locals.menuList",
      "        if locals.selectedItem == __menuItem_idx then",
      "            if locals.textColor == null then",
      "                locals.outputMenu.push(locals.menuItem.mark(locals.highlightcolor))",
      "            else",
      "                locals.outputMenu.push(locals.menuItem.color(locals.textColor).mark(locals.highlightcolor))",
      "            end if",
      "        else",
      "            locals.outputMenu.push(locals.menuItem)",
      "        end if",
      "    end for",
      "    return locals.outputMenu",
      "end function",
      "",
      "user_navigation = function (numberIndex, userInput)",
      "    indexChange = numberIndex",
      "    if locals.userInput == \"UpArrow\" then",
      "        locals.indexChange = locals.indexChange - 1",
      "    end if",
      "    if locals.userInput == \"DownArrow\" then",
      "        locals.indexChange = locals.indexChange + 1",
      "    end if",
      "    return locals.indexChange",
      "end function",
      "",
      "keepAlive = true",
      "myMenu = [\"item 1\", \"item2\", \"item3\", \"item4\"]",
      "menuSelection = 0",
      "",
      "while not userInput ==  \"LeftArrow\"",
      "    clear_screen",
      "    menu = display_menu(myMenu, menuSelection)",
      "    for line in menu",
      "        print line",
      "    end for",
      "    menuSelection = (user_navigation(menuSelection, user_input(\"\", false, true))).clamp(0, (myMenu.len - 1))",
      "end while "
    ]
  },
  "functions: extract_ip": {
    "prefix": "fn_extract_ip",
    "scope": "greyscript",
    "description": "Insert extract_ip (full, with header).",
    "body": [
      "// Extracts the first IPv4 address found in a string",
      "// @description **Description:**",
      "// @description Scans a string for a valid IPv4 address and returns the first match.",
      "// @description Returns `null` if no valid IP address is found.",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} inputString",
      "// @description - `inputString`:`string` | The text string to search for an IP address.",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `none`",
      "//",
      "// @description **Return:**",
      "// @return {string | null}",
      "// @description `string` The first matching IPv4 address, or `null` if none is found.",
      "// @description ---",
      "//",
      "// @description **Notes:**",
      "// @description - Uses a regular expression to identify IPv4 patterns.",
      "// @description - Only the **first** valid match is returned.",
      "// @description ---",
      "//",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---",
      "//",
      "// @example ",
      "// print(extractIP(\"My IP is 192.168.1.5\")) ",
      "// Output: 192.168.1.5",
      "//",
      "// @example ",
      "// print(extractIP(\"No IP here\")) ",
      "// Output: null",
      "//",
      "// @example ",
      "// print(extractIP(\"IPs: 10.0.0.1, 172.16.0.1\")) ",
      "// Output: 10.0.0.1",
      "extractIP = function(inputString)",
      "    locals.ipPattern = \"\\b(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)\\b\"",
      "    locals.matchResult = inputString.matches(locals.ipPattern)",
      "    if locals.matchResult.values.len > 0 then",
      "        return locals.matchResult.values[0]",
      "    else",
      "        return null",
      "    end if",
      "end function"
    ]
  },
  "functions: file_append": {
    "prefix": "fn_file_append",
    "scope": "greyscript",
    "description": "Insert file_append (full, with header).",
    "body": [
      "// Append to file",
      "// @description **Description:**",
      "// @description Appends data to an existing file, or creates a new file if file does not exist",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} savePath",
      "// @description - `savePath`:`<string>`",
      "// @param {string} `saveFile`:`<string>`",
      "// @description - `saveFile`:`<string>`",
      "// @param {string} `newText`:`<string>`",
      "// @description - `newText`:`<string>`",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `none`",
      "//",
      "// @description **Return:**",
      "// @return {void}",
      "// @description `void`",
      "// @description ---",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---",
      "//",
      "// @description ***footnotes***   ",
      "// @description Parameters are not checked for validity   ",
      "// @description ---        ",
      "//",
      "// @example ",
      "// @example dataString = \"0xFC45B2XR9:missspeling\"",
      "// @example",
      "// file_append(\"/DatabaseDir\", \"addressData.db\", dataString) //Appends dataString to file",
      "// @description ---  ",
      "\tfile_append = function(savePath, saveFile, newText)",
      "\t\t//********************************************",
      "\t\tlocals.fileContent = \"\"",
      "\t\tlocals.fileLocation = locals.savePath + \"/\" + locals.saveFile",
      "\t\t//********************************************\t",
      "\t\tlocals.hostComputer = get_shell.host_computer",
      "\t\tlocals.fileObj = locals.hostComputer.File(locals.fileLocation)",
      "\t\tif not locals.fileObj then",
      "\t\t\tlocals.hostComputer.touch(locals.savePath, locals.saveFile)",
      "\t\t\tlocals.fileObj = locals.hostComputer.File(locals.fileLocation)",
      "\t\tend if",
      "\t\t//********************************************",
      "\t\t//********************************************\t\t",
      "\t\tif locals.fileObj.has_permission(\"r\") then",
      "\t\t\tif locals.fileObj.has_permission(\"w\") then",
      "\t\t\t\tlocals.fileContent = locals.fileObj.get_content",
      "\t\t\t\tif locals.fileContent == null then",
      "\t\t\t\t\tlocals.fileObj.set_content(locals.newText)",
      "\t\t\t\telse",
      "\t\t\t\t\tlocals.fileObj.set_content(locals.fileContent + locals.newText)",
      "\t\t\t\tend if",
      "\t\t\telse",
      "\t\t\tprint(\"Permission Error Saving Data to: \" + locals.saveFile + \" [No Write Permission]\")",
      "\t\t\tend if",
      "\t\telse",
      "\t\t\tprint(\"Permission Error Saving Data to: \" + locals.saveFile + \" [No Read Permission]\")",
      "\t\tend if",
      "\tend function",
      "// @startuml",
      "// start",
      "// :<color:purple>fileContent = \"\"</color>;",
      "// :<color:purple>fileLocation = savePath + \"/\" + saveFile</color>;",
      "// :<color:purple>hostComputer = get_shell.host_computer</color>;",
      "// :<color:purple>fileObj = hostComputer.File(fileLocation)</color>;",
      "// if (<color:blue>fileObj does not exist?</color>) then (<color:red>Yes</color>)",
      "//   :<color:purple>Create file: touch(savePath, saveFile)</color>;",
      "//   :<color:purple>fileObj = hostComputer.File(fileLocation)</color>;",
      "// endif",
      "// if (<color:blue>fileObj has both read and write permission?</color>) then (<color:green>Yes</color>)",
      "//   :<color:purple>fileContent = fileObj.get_content</color>;",
      "//   if (<color:blue>fileContent is null?</color>) then (<color:red>Yes</color>)",
      "//     :<color:purple>Set file content to newText</color>;",
      "//   else (<color:green>No</color>)",
      "//     :<color:purple>Append newText to existing content</color>;",
      "//   endif",
      "// else (<color:red>No Read/Write Permission</color>)",
      "//   :<color:red>Print permission error</color>;",
      "// endif",
      "// stop",
      "// @enduml"
    ]
  },
  "functions: is_type": {
    "prefix": "fn_is_type",
    "scope": "greyscript",
    "description": "Insert is_type (full, with header).",
    "body": [
      "// Check if object matches specified type",
      "// @description **Description:**",
      "// @description Check if the object passed is of the specified type and return a boolean answer",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {any} object - The name of the library to load.",
      "// @description `object`:`any`",
      "// @param {string} objectType - The type expected",
      "// @description `objectType`:`string`",
      "// @description ---",
      "//",
      "// @description **Default Parameters:**",
      "// @description - none",
      "// @description ---",
      "//",
      "// @description **Links:**",
      "// @description [typeof Documentation](https://documentation.greyscript.org/#GENERAL_TYPEOF) List of standard object types",
      "// @description ---",
      "//",
      "// @description **Return:**",
      "// @return {boolean} ",
      "// @description `boolean`:`true`|`false` Whether or not the testObject was of the specified type",
      "// @description ---   ",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "//",
      "// @example",
      "// print is_typeof(cryptoLibObject, \"cryptoLib\")  //Output: true",
      "// @example",
      "// print is_typeof(metaxploitLibObject, \"metaxploitLib\") //Output: true",
      "// @example",
      "// print is_typeof(metaxploitLibObject, \"cryptoLib\") //Output: false",
      "\tis_typeof = function(testObject, objectType)",
      "\t\t\tif not typeof(locals.testObject) == locals.objectType then return false",
      "\t\t\treturn true",
      "\tend function",
      "// @startuml",
      "// start",
      "// if (<color:blue>is typeof(object) not equal to objectType?</color>) then (<color:red>Yes</color>)",
      "//   :<color:purple>return false</color>;",
      "//   stop",
      "// else (<color:green>No</color>)",
      "//   :<color:purple>return true</color>;",
      "//   stop",
      "// endif",
      "// @enduml\t"
    ]
  },
  "functions: kill_procs": {
    "prefix": "fn_kill_procs",
    "scope": "greyscript",
    "description": "Insert kill_procs (full, with header).",
    "body": [
      "kill_procs = function(computerObject = get_shell.host_computer, pid = null, killRoot = false)",
      "termItem = function(termProc)",
      "\tcomputerObject.close_program(locals.termProc)\t\t\t\t\t\t\t",
      "end function",
      "if not pid == null then",
      "\tlocals.computerObject.close_program(locals.pid)",
      "else",
      "\tlocals.procs = split(get_shell.host_computer.show_procs, char(10), 1)[1:]",
      "\tfor proc in range(1, (locals.procs).len - 1)",
      "\t\tlocals.procSections = split(proc, char(32))",
      "\t\tif not locals.procSections[0] == \"root\" then",
      "\t\t\tlocals.computerObject.close_program(locals.procSections[1])\t\t\t\t\t",
      "\t\telse if locals.procSections[0] == \"root\" and locals.killRoot == true then",
      "\t\t\ttermItem(locals.procSections[1])\t",
      "\t\tend if",
      "\t\tif locals.procSections[0] == \"root\" then",
      "\t\t\ttermItem(locals.procSections[1])\t\t\t\t",
      "\t\tend if",
      "\tend for",
      "end if",
      "end function",
      "myComputer = get_shell.host_computer",
      "kill_procs(myComputer, 5658)"
    ]
  },
  "functions: load_lib": {
    "prefix": "fn_load_lib",
    "scope": "greyscript",
    "description": "Insert load_lib (full, with header).",
    "body": [
      "// load a library with ",
      "// @description **Description:**",
      "// Loads a library from the lib directory, optionally specifiy directory, optionally verify type",
      "// @description ---",
      "// ",
      "// @description **Links:**",
      "// [Default type list](https://documentation.greyscript.org/#GENERAL_TYPEOF)",
      "// @description ---",
      "// ",
      "// @description **Parameters:**",
      "// @param {string} libName",
      "// @param {string} [libDir]",
      "// @param {string} [libType]",
      "// @description - `libName` (**string**): The file name of the library to scan.",
      "// @description - `libDir` (**string**, *optional*): The directory where the library is located.",
      "// @description - `libType` (**string**, *optional*): The expected type of the library.",
      "//",
      "// @description **Return:** `objectLibrary` | `null`",
      "// @return {objectLibrary | null}",
      "// @return {objectLibrary} ",
      "// @description ---   ",
      "// ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "//",
      "// @description *footnotes*",
      "// @description * `libName` must be full filename including extension",
      "// @description * `libDir` should not have trailing slash",
      "// @description * `libType` is case sensitive",
      "// @description ---",
      "// ",
      "// @example lib = load_lib                                              //Load metaxploit.so from /lib directory",
      "// @example lib = load_lib(\"metaxploit.so\")                             //Load a library without specifying type",
      "// @example lib = load_lib(\"customLib.so\", \"/altLib\")                   //Load a library from specified directory",
      "// @example lib = load_lib(\"crypto.so\", \"/lib\", \"cryptoLib\")            //Load a library with a specified type (null on type mismatch)",
      "load_lib = function(libName = \"metaxploit.so\", libDir = \"/lib\", libType = \"\")",
      "    locals.libLocation = locals.libDir + \"/\" + locals.libName",
      "    if locals.libName == \"\" then",
      "        return null",
      "    end if",
      "    locals.lib = include_lib(locals.libLocation)",
      "        if not typeof(locals.lib) == null then",
      "            if locals.libType == \"\" then",
      "                return locals.lib",
      "            else if typeof(locals.lib) == locals.libType then",
      "                return locals.lib",
      "\t\t\telse",
      "\t\t\t\treturn null",
      "            end if",
      "        else",
      "            return null",
      "        end if",
      "end function",
      "",
      ""
    ]
  },
  "functions: network_device_list": {
    "prefix": "fn_network_device_list",
    "scope": "greyscript",
    "description": "Insert network_device_list (full, with header).",
    "body": [
      "// Return Network Devices in a list",
      "// @description **Description**",
      "// @description Pull network devices from host computer and return a list of network device information as lists",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} [user]]",
      "// @param {string} [pass]",
      "// @description - `user` (**string**, *optional*): The username to use for access",
      "// @description - `pass` (**string**, *optional*): The password to use for access",
      "// @description ---",
      "//",
      "// @description **Default Parameters:**",
      "// @description - none",
      "//",
      "// @return {list<list<string>>}",
      "// @description **Return**",
      "// `list[list[string, string, string]]`:`[adaptor, model, monitor_enabled]`",
      "// @description ---    ",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "\tnetwork_device_list = function(user = \"\", pass = \"\")",
      "\t\tlocals.networkDevices = split(get_shell(locals.user, locals.pass).host_computer.network_devices, char(10))",
      "\t\tlocals.networkDeviceList = []",
      "\t\tfor device in locals.networkDevices",
      "\t\t\tif locals.device then locals.networkDeviceList.push(split(locals.device, \" \"))",
      "\t\tend for",
      "\t\treturn locals.networkDeviceList",
      "\tend function",
      "// @startuml",
      "// start",
      "// :<color:purple>networkDevices = split(get_shell(user, pass).host_computer.network_devices, char(10))</color>;",
      "// :<color:purple>networkDeviceList = []</color>;",
      "// :<color:blue>For each device in networkDevices</color>;",
      "// repeat",
      "//   if (<color:blue>device exists?</color>) then (<color:green>Yes</color>)",
      "//     :<color:purple>Push split(device, \" \") into networkDeviceList</color>;",
      "//   endif",
      "// repeat while (another device exists)",
      "// :<color:green>return networkDeviceList</color>;",
      "// stop",
      "// @enduml"
    ]
  },
  "functions: parse_inbox": {
    "prefix": "fn_parse_inbox",
    "scope": "greyscript",
    "description": "Insert parse_inbox (full, with header).",
    "body": [
      "// Parse Inbox Messages",
      "// @description **Description:**",
      "// @description Parses a list of mail IDs using a global `metaMail` object and extracts structured message data.",
      "// @description Each parsed message includes: `id`, `from`, `subject`, `body`",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {list<string>} mailIDList",
      "// @description - `mailIDList`:`<list<string>>` A list of message IDs to parse.",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `none`",
      "//",
      "// @description **Return:**",
      "// @return {list<object>}",
      "// @description `list<object>` A list of parsed mail objects with the structure:",
      "// @description - `id`: Message ID",
      "// @description - `from`: Sender",
      "// @description - `subject`: Subject line",
      "// @description - `body`: Full body text of the email",
      "// @description ---",
      "//",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---",
      "//",
      "// @example",
      "// mailIDs = [\"msgid-001\", \"msgid-002\"]",
      "// parsed = parse_inbox(mailIDs)",
      "// print(parsed[0].subject)  // Output: \"Subject line here\"",
      "parse_inbox = function(mailIDList)",
      "\t\tlocals.mailObjects = []",
      "\t\tlocals.bodyText = \"\"",
      "        for mailList in locals.mailIDList",
      "\t\t\tlocals.mail = new{\"id\":\"\", \"from\":\"\", \"subject\":\"\", \"summary\":\"\", \"body\":\"\"}",
      "\t\t\tlocals.rawMail = globals.metaMail.read(locals.mailList)",
      "\t\t\tlocals.segments = (locals.rawMail.split(char(10))).crop",
      "            locals.mail.from = locals.segments[0][6:]",
      "            locals.mail.subject = locals.segments[1][9:]",
      "            locals.segments.remove(0) // remove from",
      "            locals.segments.remove(0) // remove subject",
      "\t\t\tlocals.mail.id = locals.mailList",
      "            locals.mail.body = locals.segments.string ",
      "\t\t\tlocals.mailObjects.push(locals.mail)",
      "        end for",
      "        return locals.mailObjects",
      "    end function"
    ]
  },
  "functions: get_inbox": {
    "prefix": "fn_get_inbox",
    "scope": "greyscript",
    "description": "Insert get_inbox (full, with header).",
    "body": [
      "// Get Inbox Messages",
      "// @description **Description:**",
      "// @description Logs into the mail account and fetches inbox messages.",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} [mailAddress]",
      "// @description - `mailAddress`:`string` | Optional. Defaults to `user_mail_address`",
      "// @param {string} [mailPass]",
      "// @description - `mailPass`:`string` | Optional. Defaults to `\"mailpass\"`",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `mailAddress`:`user_mail_address`",
      "// @description - `mailPass`:`\"mailpass\"`",
      "//",
      "// @description **Return:**",
      "// @return {object}",
      "// @description `object` Inbox messages fetched from the mail server.",
      "// @description ---",
      "//",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---",
      "//",
      "// @example",
      "// inbox = get_inbox(\"user@example.com\", \"mypassword\",)",
      "// print(inbox)",
      "    get_inbox = function(mailAddress = user_mail_address, mailPass = null)",
      "        if mailPass == null then return null",
      "        locals.metaMail = mail_login(locals.mailAddress, locals.mailPass)",
      "\t\treturn metaMail.fetch",
      "    end function"
    ]
  },
  "functions: get_overflow_owner": {
    "prefix": "fn_get_overflow_owner",
    "scope": "greyscript",
    "description": "Insert get_overflow_owner (full, with header).",
    "body": [
      "// Get Overflow Object Owner",
      "    // @description **Description:**",
      "    // @description Determine the permission level of an object",
      "    // @description ---",
      "    //",
      "    // @description **Parameters:**",
      "    // @param {map<string,method>} overflowObject",
      "    // @description - `overflowObject`:`<object>` The object returned from the exploit",
      "    //",
      "    // @description **Return:**",
      "    // @return {string}",
      "    // @description `null` | `string` as `\"root\"`, `\"guest\"`, or `\"{user_name}\"`",
      "    // @description ---",
      "    //    ",
      "    // @description **Author:** Svarii",
      "    // @description **Version:** 0.0.1",
      "    // @description --- ",
      "    //",
      "    // @example objectOwner = get_overflow_owner(overflowResult)",
      "get_overflow_owner = function(overflowObject)",
      "    locals.overflowOwner = null",
      "    locals.overflowObjectType = typeof(locals.overflowObject)",
      "    if locals.overflowObjectType == \"file\" then",
      "        return locals.overflowObject.owner",
      "    end if",
      "    if locals.overflowObjectType == \"shell\" or locals.overflowObjectType == \"computer\" then",
      "        if locals.overflowObjectType == \"shell\" then locals.rootFolder = locals.overflowObject.host_computer.File(\"/root\")",
      "        if overflowObjectType == \"computer\" then locals.rootFolder = locals.overflowObject.File(\"/root\")",
      "        if not locals.rootFolder.has_permission(\"w\") == 0 then return \"root\"",
      "        if locals.overflowObjectType == \"shell\" then locals.homeFolders = locals.overflowObject.host_computer.File(\"/home\").get_folders",
      "        if locals.overflowObjectType == \"computer\" then locals.homeFolders = locals.overflowObject.File(\"/home\").get_folders",
      "        for userFolder in locals.homeFolders",
      "            if locals.userFolder.has_permission(\"w\") then",
      "                locals.overflowOwner = locals.userFolder.name",
      "                if not locals.overflowOwner == \"guest\" then return locals.userFolder.name",
      "            end if",
      "        end for",
      "    end if",
      "    return locals.overflowOwner           ",
      "end function"
    ]
  },
  "functions: get_random_ip": {
    "prefix": "fn_get_random_ip",
    "scope": "greyscript",
    "description": "Insert get_random_ip (full, with header).",
    "body": [
      "// Generate a random IP address",
      "// @description **Description:**",
      "// Generate a single random ip address",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @description - none ",
      "// @description ---",
      "//",
      "// @description **Return:**",
      "// @return {string}",
      "// @description `number` Randomly generated IP Address",
      "// @description ---   ",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "//",
      "// @example randomIP = get_random_ip",
      "// @example",
      "// print(randomIP) // Output: ###.###.###.###",
      "\tget_random_ip = function()",
      "\tlocals.generateRandomOctet = function()",
      "    \tlocals.binaryString = \"\"",
      "\t    for i in range(8, 1)",
      "\t        // Convert the random float to a binary digit using a threshold:",
      "\t        if rnd() >= 0.5 then",
      "\t            locals.binaryString = locals.binaryString + \"1\"",
      "\t        else",
      "\t            locals.binaryString = locals.binaryString + \"0\"",
      "\t        end if",
      "\t    end for",
      "\t    return (0 + to_int(locals.binaryString[0])) * 128 +",
      "\t           (0 + to_int(locals.binaryString[1])) * 64 +",
      "\t           (0 + to_int(locals.binaryString[2])) * 32 +",
      "\t           (0 + to_int(locals.binaryString[3])) * 16 +",
      "\t           (0 + to_int(locals.binaryString[4])) * 8 +",
      "    \t       (0 + to_int(locals.binaryString[5])) * 4 +",
      "        \t   (0 + to_int(locals.binaryString[6])) * 2 +",
      "\t           (0 + to_int(locals.binaryString[7]))",
      "\tend function",
      "    locals.ipString = \"\"",
      "    for i in range(4, 1)",
      "        locals.octet = locals.generateRandomOctet()",
      "        // Only append a dot if there is already an octet in ipString.",
      "        if locals.ipString != \"\" then",
      "            locals.ipString = locals.ipString + \".\"",
      "        end if",
      "        locals.ipString = locals.ipString + str(locals.octet)",
      "    end for",
      "    return locals.ipString",
      "\tend function",
      "// @startuml",
      "// start",
      "// :<color:purple>Define generateRandomOctet function</color>;",
      "// :<color:purple>binaryString = \"\"</color>;",
      "// :<color:blue>For i = 1 to 8</color>;",
      "// repeat",
      "//   if (<color:blue>rnd() >= 0.5?</color>) then (<color:green>Yes</color>)",
      "//     :<color:purple>binaryString = binaryString + \"1\"</color>;",
      "//   else (<color:red>No</color>)",
      "//     :<color:purple>binaryString = binaryString + \"0\"</color>;",
      "//   endif",
      "// repeat while (next bit)",
      "// :<color:purple>Calculate octet = (bit0 * 128) + (bit1 * 64) + (bit2 * 32) + (bit3 * 16) + (bit4 * 8) + (bit5 * 4) + (bit6 * 2) + (bit7)</color>;",
      "// :<color:green>return octet</color>;",
      "//",
      "// :<color:purple>Initialize ipString = \"\"</color>;",
      "// :<color:blue>For i = 1 to 4</color>;",
      "// repeat",
      "//   :<color:purple>octet = generateRandomOctet()</color>;",
      "//   if (<color:blue>ipString != \"\"?</color>) then (<color:green>Yes</color>)",
      "//     :<color:purple>ipString = ipString + \".\"</color>;",
      "//   endif",
      "//   :<color:purple>ipString = ipString + str(octet)</color>;",
      "// repeat while (next octet)",
      "// :<color:green>return ipString</color>;",
      "// stop",
      "// @enduml\t",
      ""
    ]
  },
  "functions: get_subnet": {
    "prefix": "fn_get_subnet",
    "scope": "greyscript",
    "description": "Insert get_subnet (full, with header).",
    "body": [
      "// Finds all LAN devices on the same subnet that are not routers",
      "// @description **Description:**",
      "// @description Determines which devices on a given router's LAN are **not routers themselves**.",
      "// @description Returns a list of device IPs that are part of the same subnet.",
      "// @description Returns `\"Router Not Found\"` if the input address does not map to a known router.",
      "// @description",
      "//",
      "// @description **Parameters:**",
      "// @param {string} address",
      "// @description - `string` The IP address to identify the target router.",
      "//",
      "// @description **Parameter Defaults:**",
      "// @description - `none`",
      "//",
      "// @description **Return:**",
      "// @return {list<string> | string}",
      "// @description `list<string>` A list of IP addresses on the same subnet that are not routers.",
      "// @description `string` The message `\"router not found.\"` if no router is associated with the given address.",
      "// @description",
      "//",
      "// @description **Notes:**",
      "// @description - Filters out router IPs from the LAN device list.",
      "// @description - Uses `devices_lan_ip()` to get all LAN devices associated with a router.",
      "// @description",
      "//",
      "// @description **Author:** Brostrodamus",
      "// @description **Contributor:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description",
      "//",
      "// @example ",
      "// print(get_subnet_non_routers(\"192.168.0.1\")) ",
      "// Output: [\"192.168.0.2\", \"192.168.0.3\"]",
      "//",
      "// @example ",
      "// print(get_subnet_non_routers(\"10.0.0.1\")) ",
      "// Output: \"router not found.\"",
      "get_subnet_non_routers = function(address, returnNonRouters = true, returnRouters = false)",
      "    locals.target_router = get_router(locals.address)",
      "    if locals.target_router == null then",
      "        return \"router not found.\" ",
      "    end if",
      "",
      "    locals.devices = devices_lan_ip(locals.target_router)",
      "    locals.subnet = []",
      "",
      "    for ip in locals.devices",
      "    if locals.returnNonRouters == true then",
      "        if get_router(locals.ip) == null then",
      "            subnet.push(locals.ip)",
      "        end if",
      "    end if",
      "    if locals.returnRouters == true then",
      "        if typeof(get_router(locals.ip)) == \"router\" then",
      "            subnet.push(locals.ip)",
      "        end if",
      "    end if    ",
      "    end for",
      "    return locals.subnet",
      "end function"
    ]
  },
  "functions: is_null": {
    "prefix": "fn_is_null",
    "scope": "greyscript",
    "description": "Insert is_null (full, with header).",
    "body": [
      "// Test if a object is null",
      "// @description **Description:**",
      "// Return `true` if item is null, `false` otherwise",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {any} testObject",
      "// @description - `testObject` The item to check",
      "// @description ---",
      "//",
      "// @description **Default Parameters:**",
      "// @description - none",
      "//",
      "// @description ---",
      "//",
      "// @description **Return:** `boolean`:`true`|`false`",
      "// @return {boolean} ",
      "// @description ---   ",
      "//    ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "//",
      "// @example nullItem = null",
      "// @example notNull = \"A string\"",
      "// @example",
      "// print is_null(nullItem) // Output: 1",
      "// @example",
      "// print is_null(notNull) // Output: 0",
      "is_null = function(testObject)",
      "    if locals.testObject == null then",
      "        return true",
      "    else",
      "        return false",
      "    end if",
      "end function",
      "// @startuml",
      "// start",
      "// if (<color:blue>testObject == null?</color>) then (<color:green>Yes</color>)",
      "//   :<color:purple>return true</color>;",
      "//   stop",
      "// else (<color:blue>No</color>)",
      "//   :<color:purple>return false</color>;",
      "//   stop",
      "// endif",
      "// @enduml"
    ]
  },
  "functions: stack_string": {
    "prefix": "fn_stack_string",
    "scope": "greyscript",
    "description": "Insert stack_string (full, with header).",
    "body": [
      "stack_string = function(stackStringTop, stackStringBottom, stackPosition = \"0em\")",
      "      string.pos = function(position = \"0em\")",
      "          return \"<pos=\" + position + \">\" + self + \"</pos>\"",
      "      end function",
      "      string.size = function(position = \"100%\")",
      "          return \"<size=\" + position + \">\" + self + \"</pos>\"",
      "      end function",
      "      string.sub = function",
      "          return \"<sub>\" + self + \"</sub>\"",
      "      end function",
      "      string.sup = function",
      "          return \"<sup>\" + self + \"</sup>\"",
      "      end function",
      "return stackStringTop.pos(stackPosition).sup + stackStringBottom.pos(stackPosition).sub",
      "end function",
      "",
      "//print stack_string(\"420\", \"247\", \"10%\").size(\"100%\")",
      "//print stack_string(\"365\", \"057\", \"2em\").size(\"200%\") + stack_string(\"777\", \"666\", \"155px\").size(\"300%\")"
    ]
  },
  "functions: text_crawl": {
    "prefix": "fn_text_crawl",
    "scope": "greyscript",
    "description": "Insert text_crawl (full, with header).",
    "body": [
      "",
      "loadText = get_shell.host_computer.File(home_dir + \"/Downloads/fly.txt\").get_content.split(char(10))",
      "",
      "// your percentage multipliers for each of the 7 lines",
      "multipliers = [5, 25, 45, 65, 80, 90, 100]",
      "",
      "for i in range(0, (loadText.len - multipliers.len) - 1)",
      "    // for each offset 0..6",
      "    for offset in range(0, multipliers.len - 1)",
      "        lineIdx   = i + offset",
      "        pct       = str(multipliers[offset]) + \"%\"",
      "        formatted = loadText[lineIdx].size(pct).align(\"center\")",
      "        print(formatted, true)",
      "    end for",
      "    wait 0.729",
      "end for"
    ]
  },
  "functions: unsafe_check_list": {
    "prefix": "fn_unsafe_check_list",
    "scope": "greyscript",
    "description": "Insert unsafe_check_list (full, with header).",
    "body": [
      "// **Description:**",
      "// Get name of program *{self}*",
      "// @description **Description**",
      "// @description Split Unsafe Check Results into Individual Exploit Results and return list of UnsafeCheck strings",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param {string} scanResults - The name of the library to load.",
      "// @description - `scanResults` : `string` result from `fetch_exploit_requirements()`",
      "//",
      "// @description **Default Parameters:**",
      "// @description - none",
      "// @description ---",
      "//",
      "// @return {list <string>}",
      "// @description **Return**",
      "// `list`:`string`",
      "// @description ---    ",
      "// ",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "//   ",
      "// @example libLocation = \"/lib/aptclient.so\"",
      "// @example metax = include_lib(\"/lib/metaxploit.so\")",
      "// @example metaLib = metax.load(locals.libLocation)",
      "// @example exploitMem = find_exploitable_addresses(libLocation, metaxploitObject), libLocation, metaxploitObject)",
      "// @example",
      "// unsafeCheckList = unsafe_check_list(fetch_exploit_requirments(exploitMem)",
      "\tunsafe_check_list = function(scanResults)",
      "\t\tlocals.scanResults = locals.scanResults.remove(\"decompiling source...\" + char(10) + \"searching unsecure values...\" + char(10))",
      "\t\tlocals.unsafeCheckList = locals.scanResults.split(char(10)*2)",
      "\t\treturn locals.unsafeCheckList",
      "\tend function",
      ""
    ]
  },
  "functions: program_name": {
    "prefix": "fn_program_name",
    "scope": "greyscript",
    "description": "Insert program_name (full, with header).",
    "body": [
      "// Get name of program *{self}*",
      "// @description **Description**",
      "// @description Return a string with the name of the file that is running this script",
      "// @description ---",
      "//",
      "// @description **Parameters:**",
      "// @param `none`]",
      "//",
      "// @description **Default Parameters:**",
      "// @description - none",
      "// @description ---",
      "//",
      "// @return {string}",
      "// @description **Return**",
      "// `string`:`The name of the program running`",
      "// @description ---    ",
      "//    ",
      "// @example",
      "// programName = program_name",
      "//",
      "// @description **Author:** Svarii",
      "// @description **Version:** 0.0.1",
      "// @description ---    ",
      "\tprogram_name = function()",
      "\t\tlocals.splitVal = program_path.split(\"/\")",
      "\t\tlocals.splitVal.reverse",
      "\t\treturn trim(locals.splitVal[0])",
      "\tend function"
    ]
  }
}